### PySerial 库的作用与用法详解

PySerial 是 Python 中用于串口通信的核心库，提供跨平台支持（Windows、Linux、macOS），允许开发者通过编程与串口设备（如传感器、单片机、工业控制器等）进行数据交互。以下是其核心功能与使用指南：

------

#### **一、核心作用**

1. 

   **串口通信控制**

   - 

     打开/关闭串口、设置波特率、数据位、停止位、校验位等参数。

   - 

     支持同步和异步数据读写，兼容二进制与文本数据传输。

2. 

   **数据交互**

   - 

     支持单字节读取 (`read()`)、批量读取 (`read(n)`)、按行读取 (`readline()`)。

   - 

     支持数据写入 (`write()`)，需将字符串编码为字节流（如 `b'Hello'`）。

3. 

   **异常处理与稳定性**

   - 

     提供超时机制 (`timeout`) 防止程序阻塞。

   - 

     支持流控制（硬件/软件流控，如 RTS/CTS、Xon/Xoff）避免数据丢失。

4. 

   **高级功能扩展**

   - 

     多线程/异步通信（结合 `threading`或 `asyncio`）。

   - 

     数据校验（如 CRC 校验，需配合 `crcmod`库）。

   - 

     串口扫描与状态监控（通过 `serial.tools.list_ports`）。

------

#### **二、基础用法示例**

##### **1. 安装与导入**

bash

bash

复制

```
pip install pyserial  # 安装库 [1,6](@ref)
```

python

python

下载

复制

运行

```
import serial  # 导入模块
```

##### **2. 配置与打开串口**

python

python

下载

复制

运行

```
# 配置串口参数
ser = serial.Serial(
    port='COM3',        # Windows: COMx; Linux/macOS: /dev/ttyUSBx
    baudrate=9600,      # 波特率
    bytesize=serial.EIGHTBITS,  # 数据位（5-8位）
    parity=serial.PARITY_NONE,  # 校验位（NONE, EVEN, ODD）
    stopbits=serial.STOPBITS_ONE,  # 停止位（1, 1.5, 2）
    timeout=1           # 超时时间（秒）
)

# 检查串口状态
if ser.is_open:
    print(f"已打开串口: {ser.port}")
```

##### **3. 数据读写**

python

python

下载

复制

运行

```
# 写入数据（需编码为字节流）
ser.write(b'Hello Device!')  # 发送字节数据 [3,5](@ref)

# 读取数据
data = ser.read(10)          # 读取10字节
print(data)                  # 输出：b'Hello Dev'

line = ser.readline()        # 读取至换行符
print(line.decode())         # 假设设备返回 "OK\r\n"，输出：OK
```

##### **4. 关闭串口**

python

python

下载

复制

运行

```
ser.close()  # 释放资源
```

------

#### **三、进阶功能**

##### **1. 异常处理**

python

python

下载

复制

运行

```
try:
    ser = serial.Serial('/dev/ttyUSB0', 9600, timeout=1)
    ser.write(b'START')
    response = ser.readline().decode()
except serial.SerialException as e:
    print(f"串口错误: {e}")  # 设备未连接或权限不足
except UnicodeDecodeError:
    print("解码失败，检查数据格式")
finally:
    if ser and ser.is_open:
        ser.close()
```

##### **2. 多线程并发读写**

python

python

下载

复制

运行

```
import threading

def read_data(ser):
    while True:
        if ser.in_waiting:
            data = ser.readline().decode()
            print(f"收到数据: {data}")

# 启动读取线程
thread = threading.Thread(target=read_data, args=(ser,))
thread.start()

# 主线程写入数据
ser.write(b'Ping')
```

##### **3. 串口参数动态调整**

python

python

下载

复制

运行

```
# 运行时修改参数
ser.baudrate = 115200  # 更改波特率
ser.parity = serial.PARITY_EVEN  # 设置偶校验
```

##### **4. 扫描可用串口**

python

python

下载

复制

运行

```
import serial.tools.list_ports

ports = serial.tools.list_ports.comports()
for port in ports:
    print(f"设备: {port.device}, 描述: {port.description}")
```

------

#### **四、适用场景**

1. 

   **嵌入式开发**

   - 

     与 Arduino、树莓派等设备通信，发送控制指令或读取传感器数据。

2. 

   **工业自动化**

   - 

     控制 PLC、CNC 机床，监控设备状态。

3. 

   **物联网（IoT）**

   - 

     通过串口网关连接传感器网络，实现数据采集与上报。

4. 

   **调试工具开发**

   - 

     构建串口调试助手，实时显示数据流并发送测试指令。

------

#### **五、常见问题解决**

1. 

   **串口无法打开**

   - 

     检查设备是否连接，确认串口号（如 `COM3`）正确。

   - 

     关闭占用串口的其他程序（如 Arduino IDE 的串口监视器）。

2. 

   **数据丢失或乱码**

   - 

     确保发送端和接收端的波特率、数据格式一致。

   - 

     使用 `ser.flushInput()`和 `ser.flushOutput()`清空缓冲区。

3. 

   **跨平台兼容性**

   - 

     Windows 使用 `COMx`，Linux/macOS 使用 `/dev/tty*`。

   - 

     通过 `sys.platform`动态适配路径：

     python

     python

     下载

     复制

     运行

     ```
     import sys
     if sys.platform.startswith('win'):
         port = 'COM3'
     else:
         port = '/dev/ttyUSB0'
     ```

------

#### **六、扩展库推荐**

- 

  **pyserial-asyncio**：异步串口通信，提升高并发性能 

  。

  

- 

  **pySerialTransfer**：支持数据包序列化与自动波特率检测 

  。

  

- 

  **crcmod**：实现 CRC 校验，确保数据完整性